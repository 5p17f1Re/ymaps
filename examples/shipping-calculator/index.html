<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Пример: Расчет стоимости доставки.</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<script src="http://api-maps.yandex.ru/2.0/?load=package.full&lang=ru-RU&mode=debug" type="text/javascript"></script>
<script src="https://raw.github.com/dimik/ymaps/master/multi-geocoder.js" type="text/javascript"></script>

<script type="text/javascript">
function init() {
    var myMap = window.map = new ymaps.Map('map', {
            center: [55.7, 37.5],
            zoom: 9,
            type: 'yandex#map',
            behaviors: ['scrollZoom', 'drag']
        }),
        search = new ymaps.control.SearchControl({
            useMapBounds: true,
            noCentering: true,
            noPlacemark: true
        });

    var tarifs = [{
            name: "Москва",
            area: {
                type: "Polygon",
                url: "http://maps.yandex.ru/export/usermaps/Ik1vpVgikUAKRVdtokML99zzhBLlN7BK/",
                has: function (step) {
                    return this.geometry.contains(step.end_location) && !step.street.match(/МКАД/ig);
                }
            },
            cost: 20
        }, {
            name: "Московская область",
            area: {
                type: "Polygon",
                url: "http://maps.yandex.ru/export/usermaps/K7PmDPE5MeWZw-O-x6zhZ1zboyf5YDR6/",
                has: function (step) {
                    return this.geometry.contains(step.end_location) || step.street.match(/МКАД/ig);
                }
            },
            cost: 40
        }];

    var calculator = new ShippingCalculator(myMap, myMap.getCenter(), tarifs);

    myMap.controls.add(search, { right: 5, top: 5 });

    calculator.ready(function () {
        search.events.add('resultselect', function (e) {
            var results = search.getResultsArray(),
                selected = e.get('resultIndex'),
                point = results[selected].geometry.getCoordinates();

                calculator.setDestination(point);
        });
    });
}

function ShippingCalculator(map, origin, tarifs) {
    this._map = map;
    this._routeService = new DirectionsService({ avoidTrafficJams: true });
    this._routeRenderer = new DirectionsRenderer({ draggable: true, map: map });
    this._origin = origin;
    this._tarifs = tarifs;
}

ShippingCalculator.prototype = {
    constructor: ShippingCalculator,
    ready: function (cb) {
        var map = this._map,
            tarifs = this._tarifs,
            count = tarifs.length;

        tarifs.forEach(function (tarif) {
            ymaps.geoXml.load(tarif.area.url)
                .then(function (res) {
                    var geometry = res.geoObjects.get(0).geometry;

                    geometry.setMap(map);
                    geometry.options.setParent(map.options);
                    tarif.area.geometry = geometry;
                    if(--count == 0) {
                        cb();
                    }
                });
        });
    },
    _onDestinationChange: function (e) {
        this.setDestination(e.get('coordPosition'));
    },
    getDirections: function (request) {
        var self = this;

        this._routeService.route(request, function (result) {
            self._routeRenderer.setDirections(result);
            self.calculate(result.routes[0]);
        });
    },
    setDestination: function (position) {
        this._routeRenderer.events.add('waypointschange', function (e) {
            this.getDirections({
                origin: e.get('origin'),
                destination: e.get('destination')
            });
        }, this);

        this.getDirections({
            origin: this._origin,
            destination: position // this._destination.geometry.getCoordinates()
        });
    },
    calculate: function (route) {
        // Константы.
        var coordSystem = this._map.options.get('projection').getCoordSystem(),
            MINIMUM_COST = 300,
            tarifs = this._tarifs,
            tarif, i = 0,
            results = tarifs.map(function (tarif) {
                return {
                    name: tarif.name,
                    distance: 0,
                    cost: 0
                };
            });

        route.legs.forEach(function (leg) {
            leg.steps.forEach(function (step) {
                while(tarif = tarifs[i]) {
                    var distance = 0;

                    console.log(tarif.area.has(step), !tarif.area.geometry.contains(step.start_location), tarif.name, step.street);
                    if(tarif.area.has(step)) {
                        distance = step.distance;
                    }
                    else if(!tarif.area.geometry.contains(step.start_location)) {
                        distance = step.path.reduce(function (distance, point, index, path) {
                            return tarif.area.geometry.contains(point) ?
                                distance + coordSystem.getDistance(path[index - 1] || point, point) :
                                distance;
                        }, distance);

                        if(results[i - 1]) {
                            console.log('diff', step.distance - distance);
                            results[i - 1].distance += (step.distance - distance) / 1000;
                        }
                    }
                    results[i].distance += (distance /= 1000);
                    results[i].cost += distance * tarif.cost;
                    break;

                    i += 1;
                }
            });
        });

        console.log(results);
        // return Math.max(len * DELIVERY_TARIF, MINIMUM_COST);
    }
};


function DirectionsService(options) {
    this._avoidTrafficJams = options.avoidTrafficJams;
}

DirectionsService.prototype = {
    constructor: DirectionsService,
    route: function (request, callback) {
        var self = this,
            mGeocoder = new MultiGeocoder(),
            waypoints = [request.origin]
                .concat(request.waypoints || [], [request.destination]);

        mGeocoder.geocode(waypoints).then(function (geocoder) {
            ymaps.route(waypoints, request).then(function (route) {
                callback({
                    routes: [{
                        bounds: route.properties.get('boundedBy'),
                        legs: self._getLegs(route.getPaths(), {
                            geocoderResults: geocoder.geoObjects,
                        })
                    }]
                });
            });
        });
    },
    _getLegs: function (paths, params) {
        var legs = [];

        paths.each(function (path, i) {
            var start = params.geocoderResults.get(i),
                end = params.geocoderResults.get(i + 1);

            legs.push({
                distance: path.getLength(),
                duration:  this._avoidTrafficJams ? path.getJamsTime() : path.getTime(),
                start_address: start.properties.get('text'),
                end_address: end.properties.get('text'),
                start_location: start.geometry.getCoordinates(),
                end_location: end.geometry.getCoordinates(),
                steps: this._getSteps(path.getSegments(), params)
            });
        }, this);

        return legs;
    },
    _getSteps: function (segments, params) {
        return segments.map(function (segment) {
            var path = segment.getCoordinates();

            return {
                distance: segment.getLength(),
                duration: this._avoidTrafficJams ? segment.getJamsTime() : segment.getTime(),
                instructions: segment.getHumanAction(),
                path: path,
                street: segment.getStreet(),
                start_location: path[0],
                end_location: path[path.length - 1]
            };
        });
    }
};

function DirectionsRenderer(options) {
    this.events = new ymaps.event.Manager();
    this._polyline = null;
    this._markers = new ymaps.GeoObjectArray();

    this._draggable = options.draggable;
    this._directions = options.directions;
    this._markerOptions = options.markerOptions || {};
    this._polylineOptions = options.polylineOptions || ymaps.option.presetStorage.get('router#route');
    this._routeIndex = options.routeIndex || 0;

    this._markerOptions.draggable = !!this._draggable;

    if(options.map) {
        this.setMap(options.map);
    }
}

DirectionsRenderer.ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

DirectionsRenderer.prototype = {
    constructor: DirectionsRenderer,
    setDirections: function (directions) {
        this._directions = directions;

        if(directions && this._map) {
            this._render();
        }
    },
    getDirections: function () {
        return this._directions;
    },
    getMap: function () {
        return this._map;
    },
    setMap: function (map) {
        this._map = map;

        if(map) {
            this._markers.options.setParent(map.options);
            this._markers.setParent(map.geoObjects);

            if(this._directions) {
                this._render();
            }
        }
    },
    getRouteIndex: function () {
        return this._routeIndex;
    },
    setRouteIndex: function (index) {
        this._routeIndex = index;
    },
    _clear: function () {
        this._detachHandlers();
        this._markers.removeAll();

        if(this._polyline) {
            this._map.geoObjects.remove(this._polyline);
        }
    },
    _createPolyline: function (coordinates) {
        if(!this._suppressPolylines) {
            this._polyline = new ymaps.Polyline(coordinates, {}, this._polylineOptions);
            this._map.geoObjects.add(this._polyline);
        }
    },
    _updateViewport: function (bounds) {
        if(!this._preserveViewport) {
            this._map.setBounds(bounds);
        }
    },
    _onDragEnd: function () {
        this.events.fire('waypointschange', {
            origin: this._markers.get(0).geometry.getCoordinates(),
            destination: this._markers.get(1).geometry.getCoordinates()
        });
    },
    _attachHandlers: function () {
        if(this._draggable) {
            this._markers.events.add('dragend', this._onDragEnd, this);
        }
    },
    _detachHandlers: function () {
        this._markers.events.remove('dragend', this._onDragEnd, this);
    },
    _createMarker: function (coordinates, data, options) {
        return new ymaps.Placemark(coordinates, data, options || this._markerOptions);
    },
    _render: function () {
        var coordinates = [],
            route = this._directions.routes[this._routeIndex];

        this._clear();

        route.legs.forEach(function (leg, i) {
            if(!this._suppressMarkers) {
                this._markers
                    .add(this._createMarker(leg.start_location, {
                        iconContent: DirectionsRenderer.ALPHABET.charAt(i),
                        balloonContent: leg.start_address
                    }))
                    .add(this._createMarker(leg.end_location, {
                        iconContent: DirectionsRenderer.ALPHABET.charAt(i + 1),
                        balloonContent: leg.end_address
                    }));
            }

            leg.steps.forEach(function (step) {
                coordinates = coordinates.concat(step.path);
            });
        }, this);

        this._createPolyline(coordinates);
        this._updateViewport(route.bounds);
        this._attachHandlers();
    }
};

ymaps.ready(init);

</script>
<style>
html, body, #map {
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
}
</style>
</head>

<body>
    <div id="map"></div>
</body>

</html>
