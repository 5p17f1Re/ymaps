<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Пример: Расчет стоимости доставки.</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<script src="http://api-maps.yandex.ru/2.0/?load=package.full&lang=ru-RU&mode=debug" type="text/javascript"></script>
<script src="https://raw.github.com/dimik/ymaps/master/multi-geocoder.js" type="text/javascript"></script>

<script type="text/javascript">
function init() {
    var myMap = window.map = new ymaps.Map('map', {
            center: [55.7, 37.5],
            zoom: 9,
            type: 'yandex#map',
            behaviors: ['scrollZoom', 'drag']
        }),
        search = new ymaps.control.SearchControl({
            useMapBounds: true,
            noCentering: true,
            noPlacemark: true
        });

    var calculator = new ShippingCalculator(myMap, myMap.getCenter());

    var tarifs = [{
            name: "Москва",
            cost: 20
        }, {
            name: "Московская область",
            cost: 40,
            pattern: "МКАД"
        }];

    myMap.controls.add(search, { right: 5, top: 5 });

    search.events.add('resultselect', function (e) {
        var results = search.getResultsArray(),
            selected = e.get('resultIndex'),
            point = results[selected].geometry.getCoordinates();

        calculator.setDestination(point);
    });
}

function ShippingCalculator(map, origin) {
    this._map = map;
    this._routeService = new DirectionsService({ avoidTrafficJams: true });
    this._routeRenderer = new DirectionsRenderer({ draggable: true, map: map });
    this._origin = origin;
}

ShippingCalculator.prototype = {
    constructor: ShippingCalculator,
    _onDestinationChange: function (e) {
        this.setDestination(e.get('coordPosition'));
    },
    getDirections: function (request) {
        var self = this;

        this._routeService.route(request, function (result) {
            self._routeRenderer.setDirections(result);
        });
    },
    setDestination: function (position) {
        this._routeRenderer.events.add('waypointschange', function (e) {
            this.getDirections({
                origin: e.get('origin'),
                destination: e.get('destination')
            });
        }, this);

        this.getDirections({
            origin: this._origin,
            destination: position // this._destination.geometry.getCoordinates()
        });
    },
    calculate: function (len) {
        // Константы.
        var DELIVERY_TARIF = 20,
            MINIMUM_COST = 500;

        return Math.max(len * DELIVERY_TARIF, MINIMUM_COST);
    }
};


function DirectionsService(options) {
    this._avoidTrafficJams = options.avoidTrafficJams;
}

DirectionsService.prototype = {
    constructor: DirectionsService,
    route: function (request, callback) {
        var self = this,
            mGeocoder = new MultiGeocoder(),
            waypoints = [request.origin]
                .concat(request.waypoints || [], [request.destination]);

        mGeocoder.geocode(waypoints).then(function (geocoder) {
            ymaps.route(waypoints, request).then(function (route) {
                callback({
                    routes: [{
                        bounds: route.properties.get('boundedBy'),
                        legs: self._getLegs(route.getPaths(), {
                            geocoderResults: geocoder.geoObjects,
                        })
                    }]
                });
            });
        });
    },
    _getLegs: function (paths, params) {
        var legs = [];

        paths.each(function (path, i) {
            var start = params.geocoderResults.get(i),
                end = params.geocoderResults.get(i + 1);

            legs.push({
                distance: path.getLength(),
                duration:  this._avoidTrafficJams ? path.getJamsTime() : path.getTime(),
                start_address: start.properties.get('text'),
                end_address: end.properties.get('text'),
                start_location: start.geometry.getCoordinates(),
                end_location: end.geometry.getCoordinates(),
                steps: this._getSteps(path.getSegments(), params)
            });
        }, this);

        return legs;
    },
    _getSteps: function (segments, params) {
        return segments.map(function (segment) {
            var path = segment.getCoordinates();

            return {
                distance: segment.getLength(),
                duration: this._avoidTrafficJams ? segment.getJamsTime() : segment.getTime(),
                instructions: segment.getHumanAction(),
                path: path,
                street: segment.getStreet(),
                start_location: path[0],
                end_location: path[path.length - 1]
            };
        });
    }
};

function DirectionsRenderer(options) {
    this.events = new ymaps.event.Manager();
    this._polyline = null;
    this._markers = new ymaps.GeoObjectArray();

    this._draggable = options.draggable;
    this._directions = options.directions;
    this._markerOptions = options.markerOptions || {};
    this._polylineOptions = options.polylineOptions || ymaps.option.presetStorage.get('router#route');
    this._routeIndex = options.routeIndex || 0;

    this._markerOptions.draggable = !!this._draggable;

    if(options.map) {
        this.setMap(options.map);
    }
}

DirectionsRenderer.ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

DirectionsRenderer.prototype = {
    constructor: DirectionsRenderer,
    setDirections: function (directions) {
        this._directions = directions;

        if(directions && this._map) {
            this._render();
        }
    },
    getDirections: function () {
        return this._directions;
    },
    getMap: function () {
        return this._map;
    },
    setMap: function (map) {
        this._map = map;

        if(map) {
            this._markers.options.setParent(map.options);
            this._markers.setParent(map.geoObjects);

            if(this._directions) {
                this._render();
            }
        }
    },
    getRouteIndex: function () {
        return this._routeIndex;
    },
    setRouteIndex: function (index) {
        this._routeIndex = index;
    },
    _clear: function () {
        this._detachHandlers();
        this._markers.removeAll();

        if(this._polyline) {
            this._map.geoObjects.remove(this._polyline);
        }
    },
    _createPolyline: function (coordinates) {
        if(!this._suppressPolylines) {
            this._polyline = new ymaps.Polyline(coordinates, {}, this._polylineOptions);
            this._map.geoObjects.add(this._polyline);
        }
    },
    _updateViewport: function (bounds) {
        if(!this._preserveViewport) {
            this._map.setBounds(bounds);
        }
    },
    _onDragEnd: function () {
        this.events.fire('waypointschange', {
            origin: this._markers.get(0).geometry.getCoordinates(),
            destination: this._markers.get(1).geometry.getCoordinates()
        });
    },
    _attachHandlers: function () {
        if(this._draggable) {
            this._markers.events.add('dragend', this._onDragEnd, this);
        }
    },
    _detachHandlers: function () {
        this._markers.events.remove('dragend', this._onDragEnd, this);
    },
    _createMarker: function (coordinates, data, options) {
        return new ymaps.Placemark(coordinates, data, options || this._markerOptions);
    },
    _render: function () {
        var coordinates = [],
            route = this._directions.routes[this._routeIndex];

        this._clear();

        route.legs.forEach(function (leg, i) {
            if(!this._suppressMarkers) {
                this._markers
                    .add(this._createMarker(leg.start_location, {
                        iconContent: DirectionsRenderer.ALPHABET.charAt(i),
                        balloonContent: leg.start_address
                    }))
                    .add(this._createMarker(leg.end_location, {
                        iconContent: DirectionsRenderer.ALPHABET.charAt(i + 1),
                        balloonContent: leg.end_address
                    }));
            }

            leg.steps.forEach(function (step) {
                coordinates = coordinates.concat(step.path);
            });
        }, this);

        this._createPolyline(coordinates);
        this._updateViewport(route.bounds);
        this._attachHandlers();
    }
};

ymaps.ready(init);

</script>
<style>
html, body, #map {
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
}
</style>
</head>

<body>
    <div id="map"></div>
</body>

</html>
