<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Примеры. Пользовательский макет балуна кластера.</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <link href="/bootstrap/css/bootstrap.css" rel="stylesheet">

    <script src="//yandex.st/jquery/1.8.0/jquery.min.js" type="text/javascript"></script>
    <script src="//api-maps.yandex.ru/2.0/?load=package.full&lang=ru-RU&mode=debug" type="text/javascript"></script>
    <script src="points-generator.js" type="text/javascript"></script>

    <script type="text/javascript">
var id = new function() {
    /* Префикс, имеет три применения:
         * как префикс при генерации уникальных id, он призван давать уникальность при каждом запуске страницы
         * как имя свойства в котором хранятся id выданный объекту
         * как id для window
    */
    var prefix = 'id_' + (new Date()).getTime() + Math.round(Math.random() * 10000),
        counterId = 0;

    function gen() {
        return prefix + (++counterId);
    }

    /**
     * @ignore
     * Генерирует случайный ID. Возвращает результат в виде строки символов.
     * @returns {String} ID
     * @example
     * util.id.gen(); // -> 'id_45654654654654'
     */
    this.gen = gen;


    /**
     * @ignore
     * Генерирует id и присваивает его свойству id переданного объекта. Если свойство id объекта существует,
     * то значение этого свойства не изменяется. Возвращает значение id в виде строки.
     * @param {Object} object Объект
     * @returns {String} ID
     */
    this.get = function(object) {
        return object === window ? prefix : object[prefix] || (object[prefix] =  gen());
    };
};

    ymaps.ready(function () {
        var myMap = new ymaps.Map('YMapsID', {
                center: [55.751574, 37.573856],
                zoom: 9,
                behaviors: ['scrollZoom']
            }),
            generator = new RandomPointsGenerator(),
            MyBalloonLayout = ymaps.templateLayoutFactory.createClass(
                '<div class="popover top">' +
                    '<a class="close" href="#">&times;</a>' +
                    '<div class="arrow"></div>' +
                    '<div class="popover-inner">' +
                        '<div class="tabbable tabs-left">' +
                            '$[[options.sidebarLayout]]' +
                            '<div class="tab-content">' +
                                '$[[options.mainContentLayout]]' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>', {
                build: function () {
                    var state = this.getData().state;

                    if(!state.get('activeObject')) {
                        state.set('activeObject', this.getData().properties.get('geoObjects', [null])[0]);
                    }
                    this.constructor.superclass.build.call(this);

                    this.$element = $(this.getParentElement()).find('.popover');
                    this._applyElementOffset();
                },
                /**
                 * Сдвигаем балун чтобы "хвостик" указывал на точку привязки.
                 * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/IBalloonLayout.xml#event-userclose
                 * @function
                 * @private
                 * @name applyElementOffset
                 */
                _applyElementOffset: function () {
                    this.$element.css({
                        left: -(this.$element[0].offsetWidth / 2),
                        top: -(this.$element[0].offsetHeight + this.$element.find('.arrow')[0].offsetHeight)
                    });
                }
            }),
            MyBalloonMainContentLayout = ymaps.templateLayoutFactory.createClass(
                '<div class="tab-pane active">' +
                '</div>', {
                build: function () {
                    // Сначала вызываем метод build родительского класса.
                    MyBalloonMainContentLayout.superclass.build.call(this);

                    // Нужно отслеживать, какой из пунктов левого меню выбран,
                    // чтобы обновлять содержимое правой части.
                    this.stateListener = this.getData().state.events.group()
                        .add('change', this.onStateChange, this);
                    // Запоминаем текущий активный объект.
                    this.activeObject = this.getData().state.get('activeObject');
                    this.applyContent();
                },

                clear: function () {
                    // Снимаем слушателей изменения полей.
                    this.stateListener.removeAll();
                    // А затем вызываем метод clear родительского класса.
                    MyBalloonMainContentLayout.superclass.clear.call(this);
                },

                onStateChange: function () {
                    // При изменении одного из полей состояния
                    // проверяем, не сменился ли активный объект.
                    var newActiveObject = this.getData().state.get('activeObject');
                    if (newActiveObject != this.activeObject) {
                        // Если объект изменился, нужно обновить
                        // содержимое правой части.
                        this.activeObject = newActiveObject;
                        this.applyContent();
                    }
                },

                applyContent: function () {
                    // Чтобы было удобнее формировать текстовый шаблон,
                    // создадим внутренний макет, в который будем передавать
                    // модифицированный dataSet.
                    var subLayout = new MainContentSubLayout({
                            // Поскольку внутренний макет будет отображать
                            // информацию какого-то геообъекта,
                            // будем передавать во входном хэше данные и опции
                            // текущего активного геообъекта.
                            options: this.options,
                            properties: this.activeObject.properties
                        });

                    // Прикрепляем внутренний макет к внешнему.
                    subLayout.setParentElement(this.getParentElement());
                }
            }),
            // Внутрений подмакет правой части балуна кластера.
            MainContentSubLayout = ymaps.templateLayoutFactory.createClass(
                // Мы можем использовать поля properties геообъекта,
                // так как будем передавать properties в конструктор макета.
                '<h3>$[properties.name]</h3>' +
                '<div class="row-fluid">' +
                    '$[properties.text]' +
                '</div>'
            ),
            MyBalloonSidebarLayout = ymaps.templateLayoutFactory.createClass(
                '<ul class="nav nav-tabs">' +
                    '$[[options.sidebarItemLayout]]' +
                '</ul>', {
                build: function () {
                    this.constructor.superclass.build.call(this);
                    this._sidelistElement = $('ul.nav', this.getParentElement());
                    this._createElements();
                    this._setupStateMonitors();
                },
                clear: function() {
                    this._clearStateMonitors();
                    this._clearElements();
                    this.constructor.superclass.clear.call(this);
                },
                _createElements: function() {
                    var properties = this.getData().properties,
                        geoObjects = properties.get('geoObjects', []),
                        selectedGeoObject = this.getData().state.get('activeObject', null);

                    this._listElements = [];
                    this._itemListeners = {};

                    for(var i = 0, l = geoObjects.length; i < l; i++) {
                        var SidebarItemLayout = this.getData().options.get('sidebarItemLayout'),
                            isSelected = selectedGeoObject ? geoObjects[i] == selectedGeoObject : i == 0,
                            listElement = new SidebarItemLayout({
                                data: new ymaps.data.Manager({
                                    isFirst: i == 0,
                                    itemNumber: i,
                                    isSelected: isSelected,
                                    geoObject: geoObjects[i]
                                }),
                                properties: geoObjects[i].properties,
                                options: this.getData().options,
                                parentLayout: this
                            });

                        if(isSelected) {
                            this._selectedItem = listElement;
                        }

                        this._setupItemListeners(listElement);

                        listElement.setParentElement(this._sidelistElement[0]);
                        this._listElements[i] = listElement;
                    }
                },
                _setupStateMonitors: function () {
                    this._stateMonitor = new ymaps.Monitor(this.getData().state);
                    this._stateMonitor
                        .add('activeObject', this._onActiveObjectChange, this);
                },
                _clearStateMonitors: function () {
                    this._stateMonitor.removeAll();
                    this._stateMonitor = null;
                },
                _onActiveObjectChange: function (newValue, oldvalue) {
                    if (newValue != this._selectedItem.getData().data.get('geoObject')) {
                        this._selectedItem.getData().data.set('isSelected', false);

                        var geoObjects = this.getData().properties.get('geoObjects', []),
                            selectedItemIndex = ymaps.util.array.indexOf(geoObjects, newValue);

                        if(selectedIndex == -1) {
                            selectedIndex = 0;
                        }

                        var newSelectedItem = this._listElements[selectedIndex];

                        newSelectedItem.getData().data.set('isSelected', true);
                        this._selectedItem = newSelectedItem;
                    }
                },
                _clearElements: function() {
                    for(var i = 0, l = this._listElements.length; i < l; i++) {
                        this._clearItemListeners(this._listElements[i]);
                        this._listElements[i].setParentElement(null);
                    }
                },
                _setupItemListeners: function (item) {
                    this._itemListeners[id.get(item)] = item.events.group()
                        .add('click', function () {
                            this._selectedItem.getData().data.set('isSelected', false);
                            item.getData().data.set('isSelected', true);
                            this._selectedItem = item;
                            this.getData().state.set('activeObject', item.getData().data.get('geoObject'));
                        }, this);
                },
                _clearItemListeners: function (item) {
                    this._itemListeners[id.get(item)].removeAll();
                    delete this._itemListeners[id.get(item)];
                }
            }),
            MyBalloonSidebarItemLayout = ymaps.templateLayoutFactory.createClass(
                '<li[if data.isSelected] class="active"[endif]>' +
                    '<a href="#" data-toggle="tab">$[properties.name]</a>' +
                '</li>'
            );

            // Перекрываем метод генератора меток для создания подписей к маркерам.
            generator.getPointData = function (i) {
                return {
                    clusterCaption: 'Метка ' + i,
                    name: 'Метка ' + i,
                    text: 'Метка ' + i
                };
            };

            // Создаем 200 меток внутри области видимости карты.
            var points = generator.generate(200).atBounds(myMap.getBounds()),
                clusterer = new ymaps.Clusterer({
                    // Поскольку опции задаются для кластеров, а не для всего
                    // кластеризатора, им нужно приписать префикс 'cluster'.
                    clusterDisableClickZoom: true,
                    // Если нужно задать опции для балуна кластера, то к названию
                    // опции приписываются сразу 2 префикса - 'cluster' и 'balloon'.
                    clusterBalloonLayout: MyBalloonLayout,
                    clusterBalloonMainContentLayout: MyBalloonMainContentLayout,
                    clusterBalloonSidebarLayout: MyBalloonSidebarLayout,
                    clusterBalloonSidebarItemLayout: MyBalloonSidebarItemLayout,
                    // Настроим ширину левой части балуна кластера
                    clusterBalloonSidebarWidth: 100,
                    // и ширину балуна целиком.
                    clusterBalloonWidth: 300
                });


            // Добавим геообъекты в кластеризатор.
            clusterer.add(points);
            // А сам кластеризатор добавим на карту.
            myMap.geoObjects.add(clusterer);
    });
    </script>
    <style type="text/css">
        #YMapsID {
            width: 900px;
            height: 400px;
        }
        .popover {
            display: block;
            width: 260px;
            height: 100px;
            padding: 10px;
        }
        .popover .close {
            position: absolute;
            right: 5px;
            top: 1px;
        }
    </style>
</head>
<body>
    <div class="hero-unit">
        <div class="container">
            <p>Пользовательский макет балуна кластера.</p>
            <div id="YMapsID"></div>
        </div>
    </div>
</body>
</html>
