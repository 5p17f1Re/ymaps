(function (global){
var ym = { modules: global.ymaps.modules };

(function (modules){
var project = { DEBUG: false };
if (typeof modules == 'undefined' && typeof require == 'function') {
    var modules = require('ym');
}

modules.define('util.providePackage', ['system.mergeImports'], function (provide, mergeImports) {
    provide(function (srcPackage, packageArgs) {
        var packageProvide = packageArgs[0],
            packageModules = Array.prototype.slice.call(packageArgs, 1),
            ns = mergeImports.joinImports(srcPackage.name, {}, srcPackage.deps, packageModules);

        packageProvide(ns);
    });
});
})(ym.modules);

ym.modules.define('GeoObjectEditor', [
    'util.defineClass',
    'Monitor',
    'GeoObject',
    'GeoObjectCollection',
    'GeoObjectEditor.component.DrawingControl',
    'GeoObjectEditor.component.styles'
], function (provide, defineClass, Monitor, GeoObject, GeoObjectCollection, DrawingControl, styles) {
    var defaultState = {
        editing: false,
        drawing: false,
        geometryType: 'Point'
    };
    var GeoObjectEditor = defineClass(function (map) {
        GeoObjectEditor.superclass.constructor.apply(this, arguments);

        this._map = map;
        map.geoObjects.add(this);

        this._mapCursor = null;
        this._currentObject = null;

        this._drawingControl = new DrawingControl();
        map.controls.add(this._drawingControl);

        this.state.set(defaultState);
        this._stateMonitor = new Monitor(this.state);
        this._setupMonitor();

        this._setupListeners();
    }, GeoObjectCollection, {
        _setupListeners: function () {
            this.events
                .add('mapchange', this._onMapChange, this);
            this._drawingControl.events
                .add('select', this._onControlSelect, this)
                .add('deselect', this._onControlDeselect, this);
        },
        _setupMonitor: function () {
            this._stateMonitor
                .add('drawing', this._onDrawingChange, this)
                .add('editing', this._onEditingChange, this);
        },
        _onDrawingChange: function (isDrawing) {
            if(isDrawing) {
                this._listenMapClick();
                this._addMapCursor();
            }
            else {
                this._removeMapCursor();
                this._unlistenMapClick();
            }
        },
        _onEditingChange: function (isEditing) {
            if(isEditing) {
                this._listenRightClick();
            }
            else {
                this._unlistenRightClick();
            }
        },
        _listenMapClick: function () {
            this._map.events.add('click', this._onMapClick, this);
        },
        _unlistenMapClick: function () {
            this._map.events.remove('click', this._onMapClick, this);
        },
        _listenRightClick: function (e) {
            this.events.add('contextmenu', this._onRightClick, this);
        },
        _unlistenRightClick: function (e) {
            this.events.remove('contextmenu', this._onRightClick, this);
        },
        _onRightClick: function (e) {
            this._openEditMenu(e.get('coords'));
        },
        _openEditMenu: function () {
        },
        _addMapCursor: function () {
            this._mapCursor = this._map.cursors.push('crosshair');
        },
        _removeMapCursor: function () {
            this._mapCursor.remove();
        },
        startDrawing: function () {
            this.state.set('drawing', true);
        },
        startEditing: function () {
            this.state.set('editing', true);
        },
        stopDrawing: function () {
            this.state.set('drawing', false);
        },
        stopEditing: function () {
            this.state.set('editing', false);
        },
        _onMapClick: function (e) {
            this.state.set('drawing', false);

            var coordinates = e.get('coords');
            var geoObject = this._currentObject = this._createGeoObject(coordinates);
            this.add(geoObject);
            geoObject.editor.startDrawing();
            geoObject.events.once('editorstatechange', function () {
                geoObject.editor.stopEditing();
                this._deselectDrawingControl();
            }, this);
        },
        _onControlSelect: function (e) {
            var target = e.get('target');

            this.state.set({
                geometryType: target.data.get('geometryType'),
                drawing: true
            });
        },
        _onControlDeselect: function (e) {
            var target = e.get('target');
            var geometryType = target.data.get('geometryType');
            var state = this.state;

            if(state.get('geometryType') === geometryType && state.get('drawing')) {
                state.set('drawing', false);
            }
        },
        _deselectDrawingControl: function () {
            this._drawingControl.each(function (btn) {
                if(btn.isSelected()) {
                    btn.deselect();
                }
            });
        },
        _createGeoObject: function (coordinates) {
            var geometryType = this.state.get('geometryType');

            switch(geometryType) {
                case 'Polygon':
                    coordinates = [[coordinates]];
                    break;
                case 'LineString':
                    coordinates = [coordinates];
                    break;
            }

            return new GeoObject({
                geometry: {
                    type: geometryType,
                    coordinates: coordinates
                }
            }, {
                preset: 'GeoObjectEditor#' + geometryType
            });
        }
    });

    provide(GeoObjectEditor);
});

ym.modules.define('LocationTool', [
    'util.defineClass',
    'Monitor',
    'LocationTool.component.MapView',
    'LocationTool.component.DomView'
], function (provide, defineClass, Monitor, MapView, DOMView) {
    /**
     * Класс Инструмент определения координат.
     * @class
     * @name LocationTool
     * @param {ymaps.Map} map Карта.
     */
    var LocationTool = defineClass(function (map) {
        this._domView = new DOMView();
        this._mapView = new MapView(map);
        this._monitor = new Monitor(this._mapView.state);
        this._setupMonitor();
        this._initDOMView();
    }, /** @lends LocationTool.prototype */{
        /**
         * Инициализирует DOMView начальными значениями карты.
         * @private
         * @function
         * @name LocationTool._initView
         */
        _initDOMView: function () {
            this._domView.render(this._mapView.state.getAll());
        },
        /**
         * Настраиваем монитор для наблюдения за интересующими нас полями.
         * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/Monitor.xml
         * @private
         * @function
         * @name LocationTool._setupMonitor
         */
        _setupMonitor: function () {
            this._monitor
                .add(['mapCenter', 'mapZoom', 'markerPosition'], this._onMapViewStateChange, this);
        },
        /**
         * Останавливаем наблюдение.
         * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/Monitor.xml#removeAll
         * @private
         * @function
         * @name LocationTool._clearMonitor
         */
        _clearMonitor: function () {
            this._monitor
                .removeAll();
        },
        /**
         * Обработчик изменения полей.
         * @private
         * @function
         * @name LocationTool._onMapViewStateChange
         */
        _onMapViewStateChange: function (data) {
            this._domView.render(data);
        }
    });

    provide(LocationTool);
});

ym.modules.define('control.RadioGroup', [
    'util.defineClass',
    'util.extend',
    'util.id',
    'Collection',
    'data.Manager',
    'Monitor',
    'vow',
    'event.Mapper',
    'control.RadioGroup.component.EventMappingTable'
], function (provide, defineClass, extend, Id, Collection, DataManager, Monitor, vow, EventMapper, EventMappingTable) {
    var defaultOptions = {
        margin: 5
    };
    /**
     * Класс радиогруппы для кнопок.
     * @class
     * @name RadioGroup
     */
    var RadioGroup = defineClass(function (options) {
        RadioGroup.superclass.constructor.call(this, extend({}, defaultOptions, options));
        this.state = new DataManager();
        this._optionMonitor = new Monitor(this.options);
        this._element = document.createElement('ymaps');
        this._childElements = {};
        this._setupListeners();
        this._setupMonitor();
    }, Collection, /** @lends RadioGroup.prototype */{
        add: function (child) {
            var parent = this.getParent();

            if(parent) {
                child.options.setParent(parent.options);
            }
            child.events.setParent(new EventMapper(this.events, new EventMappingTable(child)));
            child.setParent(this);

            return RadioGroup.superclass.add.call(this, child);
        },
        remove: function (child) {
            var id = Id.get(child);

            child.setParent(null);
            child.options.setParent(null);
            child.events.setParent(null);
            delete this._childElements[id];

            return RadioGroup.superclass.remove.call(this, child);
        },
        setParent: function (parent) {
            parent.getChildElement(this).then(this._onElement, this);

            return RadioGroup.superclass.setParent.call(this, parent);
        },
        getChildElement: function (child) {
            var id = Id.get(child);
            var el = this._childElements[id] = this._createChildElement();
            this._element.appendChild(el);

            return vow.resolve(el);
        },
        _createChildElement: function () {
            var el = document.createElement('ymaps');

            this._setChildElementMargin(el);

            return el;
        },
        _setChildElementMargin: function (el) {
            var options = this.options,
                side = options.get('float', 'right'),
                margin = parseFloat(options.get('margin', 5)) + 'px';

            el.style['margin'] = side === 'left'? '0 ' + margin + ' 0 0': '0 0 0 ' + margin;
        },
        _onElement: function (parentContainer) {
            parentContainer.appendChild(this._element);
        },
        _setupListeners: function () {
            this.events
                .add('select', this._onChildSelect, this)
                .add('parentchange', this._onParentChange, this);
        },
        _setupMonitor: function () {
            this._optionMonitor
                .add(['float', 'margin'], this._updateChildMargin, this);
        },
        _updateChildMargin: function () {
            this.each(function (child) {
                var el = this._childElements[Id.get(child)];

                this._setChildElementMargin(el);
            }, this);
        },
        _onParentChange: function (e) {
            var parent = this.getParent();

            this.each(function (child) {
                child.options.setParent(parent && parent.options || null);
            });
        },
        _onChildSelect: function (e) {
            var target = e.get('target');

            this.each(function (child) {
                if(target !== child && child.isSelected()) {
                    child.deselect();
                }
            });
        }
    });

    provide(RadioGroup);
});

ym.modules.define('GeoObjectEditor.component.DrawingControl', [
    'util.extend',
    'control.Button',
    'control.RadioGroup'
], function (provide, extend, Button, RadioGroup) {
    var defaultOptions = {
        float: 'left'
    };
    var DrawingControl = function (options) {
        var placemarkBtn = new Button({
            data: {
                geometryType: 'Point',
                image: 'i/button-placemark.png'
            }
        });
        var polylineBtn = new Button({
            data: {
                geometryType: 'LineString',
                image: 'i/button-polyline.png'
            }
        });
        var polygonBtn = new Button({
            data: {
                geometryType: 'Polygon',
                image: 'i/button-polygon.png'
            }
        });
        var radioGroup = new RadioGroup(extend(defaultOptions, options));

        radioGroup
            .add(placemarkBtn)
            .add(polylineBtn)
            .add(polygonBtn);

        return radioGroup;
    };

    provide(DrawingControl);
});

ym.modules.define('GeoObjectEditor.component.styles', [
    'templateLayoutFactory',
    'option.presetStorage',
    'template.filter.toJSON',
    'template.filter.geometryToBase64'
], function (provide, templateLayoutFactory, presetStorage) {

    var BalloonContentLayout = templateLayoutFactory.createClass([
        '<div style="margin:20px 0">',
            '<form>',
                '<div class="control-group">',
                    '<label class="control-label" for="coordinatesField">Координаты</label>',
                    '<div class="controls">',
                        '{% include options.coordinatesFieldLayout %}',
                    '</div>',
                '</div>',
                '{% if options.encodedCoordinatesFieldLayout %}',
                    '<div class="control-group">',
                        '<label class="control-label" for="encodedCoordinatesField">Base64 координаты</label>',
                        '<div class="controls">',
                            '{% include options.encodedCoordinatesFieldLayout %}',
                        '</div>',
                    '</div>',
                '{% endif %}',
            '</form>',
        '</div>'
    ].join(''));
    var PointCoordinatesFieldLayout = templateLayoutFactory.createClass('<input id="coordinatesField" value="{{ geometry.coordinates|toJSON }}"></input>');
    var LineStringCoordinatesFieldLayout = templateLayoutFactory.createClass('<textarea rows="3" id="coordinatesField">{{ geometry.coordinates|toJSON }}</textarea>');
    var PolygonCoordinatesFieldLayout = templateLayoutFactory.createClass('<textarea rows="3" id="coordinatesField">{{ geometry.coordinates|toJSON }}</textarea>');
    var EncodedCoordinatesFieldLayout = templateLayoutFactory.createClass('<textarea rows="2" id="encodedCoordinatesField">{{ geometry|geometryToBase64 }}</textarea>');

    presetStorage.add('GeoObjectEditor#Point', {
        balloonContentLayout: BalloonContentLayout,
        balloonCoordinatesFieldLayout: PointCoordinatesFieldLayout
    });
    presetStorage.add('GeoObjectEditor#LineString', {
        balloonContentLayout: BalloonContentLayout,
        balloonCoordinatesFieldLayout: LineStringCoordinatesFieldLayout,
        balloonEncodedCoordinatesFieldLayout: EncodedCoordinatesFieldLayout
    });
    presetStorage.add('GeoObjectEditor#Polygon', {
        balloonContentLayout: BalloonContentLayout,
        balloonCoordinatesFieldLayout: PolygonCoordinatesFieldLayout,
        balloonEncodedCoordinatesFieldLayout: EncodedCoordinatesFieldLayout
    });

    provide(presetStorage);
});

ym.modules.define('LocationTool.component.CrossControl', [
    'util.defineClass',
    'templateLayoutFactory',
    'collection.Item',
    'data.Manager',
    'option.Manager',
    'event.Manager'
], function (provide, defineClass, templateLayoutFactory, CollectionItem, DataManager, OptionManager, EventManager) {
    /**
     * Класс контрола "центр карты".
     * @class
     * @name CrossControl
     */
    var CrossControl = defineClass(function (params) {
        params = params || {};
        this.events = new EventManager();
        this.options = new OptionManager(params.options);
    }, CollectionItem, /** @lends CrossControl.prototype */{
        /**
         * Устанавливает родительский объект.
         * @function
         * @name CrossControl.setParent
         * @param {IControlParent} parent Родительский объект.
         * @returns {CrossControl} Возвращает ссылку на себя.
         */
        setParent: function (parent) {
            this.parent = parent;

            if(parent) {
                var map = this._map = parent.getMap();
                this._setPosition(map.container.getSize());
                this._setupListeners();
                /**
                 * Передаем в макет контрола данные о его опциях.
                 * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/ILayout.xml#constructor-summary
                 */
                this.layout = new CrossControlLayout({ options: this.options });
                /**
                 * Контрол будет добавляться в pane событий, чтобы исключить интерактивность.
                 * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/ILayout.xml#setParentElement
                 */
                this.layout.setParentElement(map.panes.get('events').getElement());
            }
            else {
                this.layout.setParentElement(null);
                this._clearListeners();
            }

            return this;
        },
        /**
         * Возвращает ссылку на родительский объект.
         * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/IControl.xml#getParent
         * @function
         * @name CrossControl.getParent
         * @returns {IControlParent} Ссылка на родительский объект.
         */
        getParent: function () {
            return this.parent;
        },
        /**
         * Устанавливает контролу опцию "position".
         * @function
         * @private
         * @name CrossControl._setPosition
         * @param {Array} size Размер контейнера карты.
         */
        _setPosition: function (size) {
            // -8, так как картинка 16х16
            this.options.set('position', {
                top: size[1] / 2 - 8,
                right: size[0] / 2 - 8
            });
        },
        _onPositionChange: function (e) {
            this._setPosition(e.get('newSize'));
        },
        _setupListeners: function () {
            this._map.container.events
                .add('sizechange', this._onPositionChange, this);
        },
        _clearListeners: function () {
            if(this._map) {
                this._map.container.events
                    .remove('sizechange', this._onPositionChange, this);
            }
        }
    });

    /**
     * Макет контрола.
     * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/templateLayoutFactory.xml
     * @class
     * @name CrossControl.Layout
     */
    var CrossControlLayout = templateLayoutFactory.createClass(
        '<div class="cross-control" style="right:{{ options.position.right }}px; top:{{ options.position.top }}px;"></div>'
    );

    provide(CrossControl);
});

ym.modules.define('LocationTool.component.DomView', [
    'util.defineClass'
], function (provide, defineClass) {
    /**
     * Класс DOM-отображения Инструмента определения координат.
     * @class
     * @name DOMView
     */
    var DOMView = defineClass(function () {
        this._element = $('form');
    }, /** @lends DOMView.prototype */{
        /**
         * Отображаем изменений данных в DOM-структуре.
         * @function
         * @name DOMView.render
         * @param {Object} data Объект с полями "mapCenter", "mapZoom" и "markerPosition".
         */
        render: function (data) {
            $.each(data, $.proxy(this._setData, this));
        },
        /**
         * Очистка DOM-отображения.
         * @function
         * @private
         * @name DOMView.clear
         */
        clear: function () {
            this._element.remove();
        },
        /**
         * Форматируем координату до 6-ти точек после запятой.
         * @function
         * @private
         * @name DOMView._toFixedNumber
         * @param {Number|String} coords Широта или Долгота.
         * @returns {Number} Число фиксированной длины.
         */
        _toFixedNumber: function (coords) {
            return Number(coords).toFixed(8);
        },
        /**
         * Обновление значений полей формы.
         * @function
         * @private
         * @name DOMView._setData
         * @param {String} id Идентификатор поля.
         * @param {Number|String} value Новое значение поля.
         */
        _setData: function (id, value) {
            this._element
                .find('#' + id)
                .val(
                    $.isArray(value)?
                        $.map(value, this._toFixedNumber).join(', ') : value
                );
        }
    });

    provide(DOMView);
});

ymaps.modules.define('LocationTool.component.MapView', [
    'Placemark',
    'data.Manager',
    'util.defineClass',
    'util.bind'
], function (provide, Placemark, DataManager, defineClass, bind) {
    /**
     * Класс отображения на карте Инструмента определения координат.
     * @class
     * @name MapView
     * @param {ymaps.Map} map Карта.
     */
    var MapView = defineClass(function (map) {
        this._map = map;
        // Интервал обновления данных (millisec) при кинетическом движении карты.
        this._updateTimeout = 10;
        this._marker = this._createDraggableMarker();
        map.geoObjects.add(this._marker);
        this.state = new DataManager({
            mapCenter: map.getCenter(),
            mapZoom: map.getZoom(),
            markerPosition: map.getCenter()
        });
        this._setupListeners();
    }, /** @lends MapView.prototype */{
        /**
         * Навешиваем обработчики.
         * @function
         * @private
         * @name MapView._setupListeners
         */
        _setupListeners: function () {
            this._map.events
                .add('boundschange', this._onMapBoundsChange, this)
                .add('actiontick', this._onMapAction, this)
                /* Во время плавного движения карты, у браузеров поддерживающих CSS3 Transition,
                 * actiontick не кидается, поэтому используем этот прием через setInterval.
                 */
                .add('actionbegin', this._onMapActionBegin, this)
                .add('actionend', this._onMapActionEnd, this);

            this._marker.events
                .add('drag', this._onMarkerDrag, this);
        },
        /**
         * Снимаем обработчики.
         * @function
         * @private
         * @name MapView._detachListeners
         */
        _detachListeners: function () {
            this._marker.events
                .remove('drag', this._onMarkerDrag, this);

            this._map.events
                .remove('boundschange', this._onMapBoundsChange, this)
                .remove('actiontick', this._onMapAction, this)
                .remove('actionbegin', this._onMapActionBegin, this)
                .remove('actionend', this._onMapActionEnd, this);
        },
        /**
         * Обработчик перетаскивания метки.
         * @function
         * @private
         * @name MapView._onMarkerDrag
         * @param {ymaps.Event} e Объект-событие
         */
        _onMarkerDrag: function (e) {
            this.state.set({
                markerPosition: e.get('target').geometry.getCoordinates()
            });
        },
        /**
         * Обработчик начала плавного движения карты.
         * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/Map.xml#event-actionbegin
         * @function
         * @private
         * @name MapView._onMapActionBegin
         * @param {ymaps.Event} e Объект-событие
         */
        _onMapActionBegin: function (e) {
            if(this._intervalId) {
                return;
            }

            this._intervalId = window.setInterval(
                bind(this._onMapAction, this),
                this._updateTimeout
            );
        },
        /**
         * Обработчик окончания плавного движения карты.
         * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/Map.xml#event-actionend
         * @function
         * @private
         * @name MapView._onMapActionEnd
         * @param {ymaps.Event} e Объект-событие
         */
        _onMapActionEnd: function (e) {
            window.clearInterval(this._intervalId);
            this._intervalId = null;
        },
        /**
         * Обработчик исполнения нового шага плавного движения.
         * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/Map.xml#event-actiontick
         * @function
         * @private
         * @name MapView._onMapAction
         * @param {ymaps.Event} e Объект-событие
         */
        _onMapAction: function (e) {
            /**
             * Определяет состояние карты в момент ее плавного движения.
             * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/map.action.Manager.xml#getCurrentState
             */
            var state = this._map.action.getCurrentState(),
                zoom = state.zoom,
                /**
                 * Преобразует пиксельные координаты на указанном уровне масштабирования в координаты проекции (геокоординаты).
                 * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/IProjection.xml#fromGlobalPixels
                 */
                center = this._map.options.get('projection').fromGlobalPixels(
                    state.globalPixelCenter, zoom
                );

            this.state.set({
                mapCenter: center,
                mapZoom: zoom
            });
        },
        /**
         * Обработчик события изменения области просмотра карты (в результате изменения центра или уровня масштабирования)
         * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/Map.xml#event-boundschange
         * @function
         * @private
         * @name MapView._onMapBoundsChange
         * @param {ymaps.Event} e Объект-событие
         */
        _onMapBoundsChange: function (e) {
            this.state.set({
                mapCenter: e.get('newCenter'),
                mapZoom: e.get('newZoom')
            });
        },
        /**
         * Создание перетаскиваемого маркера.
         * @function
         * @private
         * @name MapView._createDraggableMarker
         */
        _createDraggableMarker: function () {
            return new Placemark(this._map.getCenter(), {
                hintContent: 'Перетащите метку'
            }, {
                draggable: true
            });
        }
    });

    provide(MapView);
});

ym.modules.define('template.filter.geometryToBase64', [
    'template.filtersStorage'
], function (provide, filtersStorage, LineString, Polygon) {

    var geometryToBase64 = function (data, value, param) {
        var geometry = value.getObject();

        return geometry.constructor.toEncodedCoordinates(geometry);
    };

    filtersStorage.add('geometryToBase64', geometryToBase64);

    provide(filtersStorage);
});

ym.modules.define('template.filter.toJSON', [
    'template.filtersStorage'
], function (provide, filtersStorage) {

    var toJSON = function (data, value, param) {
        return JSON.stringify(value);
    };

    filtersStorage.add('toJSON', toJSON);

    provide(filtersStorage);
});

ym.modules.define('control.RadioGroup.component.EventMappingTable', [
    'util.defineClass',
    'Event'
], function (provide, defineClass, Event) {
    var EventMappingTable = function (context) {
        this._context = context;
        this['*'] = this._defaultMappingFunction;

        this['parentchange'] = false;
        this['mapchange'] = false;
        this['optionschange'] = false;
    };

    defineClass(EventMappingTable, {
        _defaultMappingFunction: function (event) {
            return new Event({
                currentTarget: this._context
            }, event);
        }
    });

    provide(EventMappingTable);
});

})(this);