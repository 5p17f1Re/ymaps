(function (global){
var ym = { modules: global.ymaps.modules };
ym.modules.define('TrafficResearch.component.LegendControl', [
    'util.defineClass',
    'collection.Item',
    'data.Manager',
    'option.Manager',
    'event.Manager',
    'templateLayoutFactory',
    'vow'
], function (provide, defineClass, CollectionItem, DataManager, OptionManager, EventManager, templateLayoutFactory, vow) {
    var LegendControlLayout = templateLayoutFactory.createClass('{{ data.content|raw }}');
    var LegendControl = defineClass(function (params) {
        params = params || {};
        this.events = new EventManager();
        this.options = new OptionManager(params.options || {});
        this.data = new DataManager(params.data || {});
    }, {
        /**
         * Устанавливает родительский объект.
         * @function
         * @name LegendControl.setParent
         * @param {IControlParent} parent Родительский объект.
         * @returns {LegendControl} Возвращает ссылку на себя.
         */
        setParent: function (parent) {
            this.parent = parent;

            /**
             * Передаем в макет контрола данные и опции.
             * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/ILayout.xml#constructor-summary
             */
            var layout = new LegendControlLayout({
                    options: this.options,
                    data: this.data
                });

            if(parent) {
                parent.getChildElement(this)
                    .then(layout.setParentElement, layout);
            }
            else {
                layout.setParentElement(null);
            }

            return this;
        },
        /**
         * Возвращает ссылку на родительский объект.
         * @see http://api.yandex.ru/maps/doc/jsapi/2.x/ref/reference/IControl.xml#getParent
         * @function
         * @name LegendControl.getParent
         * @returns {IControlParent} Ссылка на родительский объект.
         */
        getParent: function () {
            return this.parent;
        }
    });

    provide(LegendControl);
});

ym.modules.define('TrafficResearch.component.TrafficLayer', [
    'Layer',
    'vow'
], function (provide, Layer, vow) {

    var TrafficLayer = function (tileUrlTemplate, options) {
        return function () {
            var layer = new Layer(tileUrlTemplate, options);

            // Копирайты
            if(options.copyright) {
                layer.getCopyrights = function () {
                    return vow.resolve(options.copyright);
                };
            }

            // Диапазон доступных масштабов на данном слое карты
            if(options.minZoom >= 0 && options.maxZoom >= 0) {
                layer.getZoomRange = function () {
                    return vow.resolve([options.minZoom, options.maxZoom]);
                };
            }

            return layer;
        };
    };

    provide(TrafficLayer);
});

ym.modules.define('TrafficResearch', [
    'util.defineClass',
    'Map',
    'layer.storage',
    'MapType',
    'mapType.storage',
    'control.TypeSelector',
    'projection.Cartesian',
    'TrafficResearch.component.TrafficLayer',
    'TrafficResearch.component.LegendControl'
], function (provide, defineClass, Map, layerStorage, MapType, mapTypeStorage, TypeSelector, Cartesian, TrafficLayer, LegendControl) {

    var TrafficResearch = defineClass(function (options) {
        var layer = this._layer = this._createLayer(options.layer);
        var mapType = this._mapType = this._createMapType(options.layer);
        var map = this._map = new Map(options.map.id, options.map, {
            projection: new Cartesian([[-1, -1], [1, 1]], [false, false])
        });

        map.controls.add(new LegendControl({ data: { content: '<img src="i/legend.png"/>' } }), { float: 'left', position: { bottom: 10, left: 10 }});
        map.setType(options.map.type);
    }, {
        _createLayer: function (options) {
            var layer = new TrafficLayer(options.tileUrlTemplate, options);
            layerStorage.add(options.id, layer);

            return layer;
        },
        _createMapType: function (options) {
            var mapType = new MapType(options.title, [options.id]);
            mapTypeStorage.add(options.id, mapType);

            return mapType;
        }
    });

    provide(TrafficResearch);
});


(function (modules){
var project = { DEBUG: false };
if (typeof modules == 'undefined' && typeof require == 'function') {
    var modules = require('ym');
}

modules.define('util.providePackage', ['system.mergeImports'], function (provide, mergeImports) {
    provide(function (srcPackage, packageArgs) {
        var packageProvide = packageArgs[0],
            packageModules = Array.prototype.slice.call(packageArgs, 1),
            ns = mergeImports.joinImports(srcPackage.name, {}, srcPackage.deps, packageModules);

        packageProvide(ns);
    });
});
})(ym.modules);

})(this);