<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Примеры. Построение сегмента круга.</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <link href="/bootstrap/css/bootstrap.css" rel="stylesheet">

    <script src="//api-maps.yandex.ru/2.0.31/?load=package.standard,package.geoObjects&mode=debug&lang=ru-RU" type="text/javascript"></script>

    <script type="text/javascript">
        ymaps.ready(init);

        function init() {
            var myMap = new ymaps.Map('YMapsID', {
                    center: [55.755768, 37.617671],
                    zoom: 10,
                    behaviors: [/*"default", */"scrollZoom"]
                });

new CircleSector(myMap);
/*
var center = myMap.getCenter(),
    middlePoint = [30, 60],
    sectorAngle = Math.PI / 4,
    // Решаем обратную задачу между двумя точками.
    geodesic = ymaps.coordSystem.geo.solveInverseProblem(point1, middlePoint),
    // Находим угол в радианах.
    azimuth = Math.atan2.apply(null, geodesic.startDirection),
    // Находим азимуты сторон треугольника.
    azimuth2 = azimuth - sectorAngle / 2,
    azimuth3 = azimuth + sectorAngle / 2,
    // Находим направления для сторон треугольника.
    dir2 = [Math.sin(azimuth2), Math.cos(azimuth2)],
    dir3 = [Math.sin(azimuth3), Math.cos(azimuth3)],
    // Находим длину гипотенузы в метрах.
    hypotenuseLength = geodesic.distance / Math.cos(sectorAngle / 2),
    // Находим координаты точек треугольника.
    point2 = ymaps.coordSystem.geo.solveDirectProblem(point1, dir2, hypotenuseLength).endPoint,
    point3 = ymaps.coordSystem.geo.solveDirectProblem(point1, dir3, hypotenuseLength).endPoint,
    // Создаем объект, не забываем указать ему опцию geodesic: true.
    triangle = new ymaps.Polygon([[point1, point2, point3]], {}, { geodesic: true });

console.log(azimuth2, azimuth3);

myMap.geoObjects.add(triangle);
var points = [];

for(var i = azimuth2; i < azimuth3; i += 0.01) {
    var dir = [Math.sin(i), Math.cos(i)]
        point = ymaps.coordSystem.geo.solveDirectProblem(point1, dir, hypotenuseLength).endPoint;
points.push(point);
}

console.log(points);
myMap.geoObjects.add(new ymaps.Polyline(points));
*/
        }

function CircleSector(map) {
    this._model = new CircleSector.Model(map);
    this._view = new CircleSector.MapView(map);

    this._isCenterSelected = false;
    this._isRadiusSelected = false;
    this._isAngleSelected = false;

    this._attachHandlers();

    this._view.setCursor('crosshair');
}

CircleSector.prototype = {
    constructor: CircleSector,
    _attachHandlers: function () {
        this._model.events
            .add('selectcenter', this._onCenterSelected, this)
            .add('selectradius', this._onRadiusSelected, this)
            .add('searchvalue', this._onSearchValue, this)
            .add('selectangle', this._onAngleSelected, this)
    },
    _detachHandlers: function () {
        this._model.events
            .remove('selectangle', this._onAngleSelected, this)
            .remove('searchvalue', this._onSearchValue, this)
            .remove('selectradius', this._onRadiusSelected, this)
            .remove('selectcenter', this._onCenterSelected, this);
    },
    _onCenterSelected: function (e) {
        this._isCenterSelected = true;
        this._view
            .setCenter(e.get('coordPosition'))
            .setCenterIcon()
            .setCursor('move');
    },
    _onRadiusSelected: function (e) {
        this._isRadiusSelected = true;
        this._view
            .drawRadius(e.get('coordPosition'));
    },
    _onSearchValue: function (e) {
        if(this._isRadiusSelected) {
            this._view
                .drawSector(e.get('coordPosition'));
        }
        else {
            this._view
                .drawRadius(e.get('coordPosition'));
        }
    },
    _onAngleSelected: function (e) {
        this._view
            .drawSector(e.get('coordPosition'));
    },
};

CircleSector.Model = function (map) {
    this._observable = map;
    this.events = new ymaps.event.Manager();

    this._attachHandlers();
};

CircleSector.Model.prototype = {
    constructor: CircleSector.Model,
    _attachHandlers: function () {
        this._observable.events
            .add('mousedown', this._onMouseDown, this)
            .add('mouseup', this._onMouseUp, this);
        this._observable.geoObjects.events
            .add('mouseup', this._onMouseUp, this);
    },
    _detachHandlers: function () {
        this._observable.geoObjects.events
            .remove('mouseup', this._onMouseUp, this);
        this._observable.events
            .remove('mouseup', this._onMouseUp, this)
            .remove('mousedown', this._onMouseDown, this);
    },
    _attachMovementHandlers: function () {
        this._observable.events
            .add('mousemove', this._onMouseMove, this);
    },
    _detachMovementHandlers: function () {
        this._observable.events
            .remove('mousemove', this._onMouseMove, this);
    },
    _attachClickHandlers: function () {
        this._observable.events
            .add('click', this._onClick, this);
    },
    _detachClickHandlers: function () {
        this._observable.events
            .remove('click', this._onClick, this);
    },
    _onMouseDown: function (e) {
        this._attachMovementHandlers();
        this.events.fire('selectcenter', e);
    },
    _onMouseUp: function (e) {
        this._detachMovementHandlers();
        this.events.fire('selectradius', e);
        this._detachHandlers();
        this._attachMovementHandlers();
    },
    _onMouseMove: function (e) {
        this.events.fire('searchvalue', e);
    },
    _onClick: function (e) {
        this._detachClickHandlers();
        this.events.fire('selectangle', e);
        this._attachHandlers();
    }
};

CircleSector.MapView = function (map) {
    this._map = map;

    this._center = null;
    this._radius = null;
    this._sector = null;
    this._direction = null;

    this.events = new ymaps.event.Manager();
};

CircleSector.MapView.prototype = {
    constructor: CircleSector.MapView,
    setCursor: function (key) {
        this._cursor = this._map.cursors.push(key);

        return this;
    },
    clearCursor: function () {
        this._cursor.remove();

        return this;
    },
    setCenter: function (position) {
        this._updateCenter(position);

        return this;
    },
    clearCenter: function () {
        if(this._center) {
            this._map.geoObjects.remove(this._center);
            this._center = null;
        }

        return this;
    },
    _updateCenter: function (position) {
        if(this._center) {
            this._center.geometry.setCoordinates(position);
        }
        else {
            this._map.geoObjects.add(
                this._center = new ymaps.Placemark(position, {}, {
                    overlayFactory: 'default#interactiveGraphics',
                    iconImageHref: 'icons.png',
                    iconImageSize: [21, 21],
                    iconImageOffset: [-10, -10],
                    iconImageClipRect: [[0, 0], [21, 21]]
                })
            );
        }
    },
    setCenterIcon: function () {
        this._center.options.set({
            iconImageClipRect: [[21, 0], [42, 21]]
        });

        return this;
    },
    _rotateCenterIcon: function (azimuth) {
        var angle = 90 - azimuth * 180 / Math.PI;

        this._center.options.set({
            iconImageRotation: angle
        });
    },
    drawRadius: function (position) {
        var center = this._center.geometry.getCoordinates(),
            geodesic = ymaps.coordSystem.geo.solveInverseProblem(center, position),
            azimuth = Math.atan2(geodesic.startDirection[0], geodesic.startDirection[1]);

        this._updateRadius(position);

        this._map.hint.show(position, {
            content: ymaps.formatter.distance(geodesic.distance)
        });

        this._rotateCenterIcon(azimuth);

        return this;
    },
    clearRadius: function () {
        if(this._radius) {
            this._map.geoObjects.remove(this._radius);
            this._radius = null;
        }

        return this;
    },
    _updateRadius: function (position) {
        var center = this._center.geometry.getCoordinates();

        if(this._radius) {
            this._radius.geometry.setCoordinates([center, position]);
        }
        else {
            this._map.geoObjects.add(
                this._radius = new ymaps.Polyline([center, position], {}, {
                    strokeStyle: 'dash'
                })
            );
        }
    },
    drawSector: function (position) {
        var coordSystem = ymaps.coordSystem.geo,
            center = this._center.geometry.getCoordinates(),
            pointA = this._radius.geometry.get(1),
            // Решаем обратную задачу между двумя точками.
            geodesicA = coordSystem.solveInverseProblem(center, pointA),
            geodesicB = coordSystem.solveInverseProblem(center, position),
            // Находим угол в радианах.
            azimuthA = Math.atan2(geodesicA.startDirection[0], geodesicA.startDirection[1]),
            azimuthB = Math.atan2(geodesicB.startDirection[0], geodesicB.startDirection[1]),
            // Находим расстояние.
            distance = geodesicA.distance,
            // Находим второй конец дуги.
            pointB = coordSystem.solveDirectProblem(center, geodesicB.startDirection, distance).endPoint,
            angleA = azimuthA,
            angleB = azimuthB,
            coordinates = [center],
            // Определяем направление в котором рисуется сектор.
            direction = - (geodesicA.startDirection[0] * geodesicB.startDirection[1] - geodesicA.startDirection[1] * geodesicB.startDirection[0]);

        if(!this._direction || (this._direction * direction < 0 && Math.abs(angleA - angleB) < 0.01)) {
            this._direction = direction;
        }

        if(this._direction >= 0 && angleA > angleB) {
            angleB += 2 * Math.PI;
        }
        else if(this._direction < 0 && angleA < angleB) {
            angleA += 2 * Math.PI;
        }

        var step = Math.abs(angleA - angleB) / Math.ceil(Math.abs(angleA - angleB) / 0.01);

        while (Math.abs(angleA - angleB) >= 1e-6) {
            var dir = [Math.sin(angleA), Math.cos(angleA)],
                point = coordSystem.solveDirectProblem(center, dir, distance).endPoint;

            coordinates.push(point);
            angleA += this._direction > 0 ? step : -step;
        }

        this._updateSector(coordinates);

        return this;
    },
    clearSector: function () {
        if(this._sector) {
            this._map.geoObjects.remove(this._sector);
            this._sector = null;
        }

        return this;
    },
    _updateSector: function (coords) {
        if(this._sector) {
            this._sector.geometry.set(0, coords);
        }
        else {
            this._map.geoObjects.add(
                this._sector = new ymaps.Polygon([coords], {}, {
                    // simplification: false,
                    geodesic: true,
                    overlayFactory: 'default#staticGraphics'
                })
            );
        }
    },
};

    </script>
    <style type="text/css">
        #YMapsID {
            width: 900px;
            height: 400px;
        }
    </style>
</head>
<body>
    <div class="hero-unit">
        <div class="container">
            <p>Построение сегмента круга</p>
            <div id="YMapsID"></div>
        </div>
    </div>
</body>
</html>
