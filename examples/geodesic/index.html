<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Примеры. Построение сегмента круга.</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <link href="/bootstrap/css/bootstrap.css" rel="stylesheet">

    <script src="//api-maps.yandex.ru/2.0.31/?load=package.standard,package.geoObjects&mode=debug&lang=ru-RU" type="text/javascript"></script>

    <script type="text/javascript">
        ymaps.ready(init);

        function init() {
            var myMap = new ymaps.Map('YMapsID', {
                    center: [55.755768, 37.617671],
                    zoom: 10,
                    behaviors: [/*"default", */"scrollZoom"]
                });

new CircleSector(myMap);
/*
var center = myMap.getCenter(),
    middlePoint = [30, 60],
    sectorAngle = Math.PI / 4,
    // Решаем обратную задачу между двумя точками.
    geodesic = ymaps.coordSystem.geo.solveInverseProblem(point1, middlePoint),
    // Находим угол в радианах.
    azimuth = Math.atan2.apply(null, geodesic.startDirection),
    // Находим азимуты сторон треугольника.
    azimuth2 = azimuth - sectorAngle / 2,
    azimuth3 = azimuth + sectorAngle / 2,
    // Находим направления для сторон треугольника.
    dir2 = [Math.sin(azimuth2), Math.cos(azimuth2)],
    dir3 = [Math.sin(azimuth3), Math.cos(azimuth3)],
    // Находим длину гипотенузы в метрах.
    hypotenuseLength = geodesic.distance / Math.cos(sectorAngle / 2),
    // Находим координаты точек треугольника.
    point2 = ymaps.coordSystem.geo.solveDirectProblem(point1, dir2, hypotenuseLength).endPoint,
    point3 = ymaps.coordSystem.geo.solveDirectProblem(point1, dir3, hypotenuseLength).endPoint,
    // Создаем объект, не забываем указать ему опцию geodesic: true.
    triangle = new ymaps.Polygon([[point1, point2, point3]], {}, { geodesic: true });

console.log(azimuth2, azimuth3);

myMap.geoObjects.add(triangle);
var points = [];

for(var i = azimuth2; i < azimuth3; i += 0.01) {
    var dir = [Math.sin(i), Math.cos(i)]
        point = ymaps.coordSystem.geo.solveDirectProblem(point1, dir, hypotenuseLength).endPoint;
points.push(point);
}

console.log(points);
myMap.geoObjects.add(new ymaps.Polyline(points));
*/
        }

function CircleSector(map) {
    this._model = new CircleSector.Model(map);
    this._view = new CircleSector.MapView(map);

    this._isCenterSelected = false;
    this._isRadiusSelected = false;
    this._isAngleSelected = false;

    this._attachHandlers();
}

CircleSector.prototype = {
    constructor: CircleSector,
    _attachHandlers: function () {
        this._model.events
            .add('selectcenter', this._onCenterSelected, this)
            .add('selectradius', this._onRadiusSelected, this)
            .add('searchvalue', this._onSearchValue, this)
            .add('selectangle', this._onAngleSelected, this)
    },
    _detachHandlers: function () {
        this._model.events
            .remove('selectangle', this._onAngleSelected, this)
            .remove('searchvalue', this._onSearchValue, this)
            .remove('selectradius', this._onRadiusSelected, this)
            .remove('selectcenter', this._onCenterSelected, this);
    },
    _onCenterSelected: function (e) {
        this._isCenterSelected = true;
        this._view
            .unsetCenter()
            .setCenter(e.get('coordPosition'));
    },
    _onRadiusSelected: function (e) {
        this._isRadiusSelected = true;
        this._view
            // .clearRadius()
            .setRadius(e.get('coordPosition'));
    },
    _onSearchValue: function (e) {
        if(this._isRadiusSelected) {
            this._view
                .unsetAngle()
                .setAngle(e.get('coordPosition'));
        }
        else {
            this._view
                // .clearRadius()
                .setRadius(e.get('coordPosition'));
        }
    },
    _onAngleSelected: function (e) {
        this._view
            .unsetAngle()
            .setAngle(e.get('coordPosition'));
    },
};

CircleSector.Model = function (map) {
    this._observable = map;
    this.events = new ymaps.event.Manager();

    this._attachHandlers();
};

CircleSector.Model.prototype = {
    constructor: CircleSector.Model,
    _attachHandlers: function () {
        this._observable.events
            .add('mousedown', this._onMouseDown, this)
            .add('mouseup', this._onMouseUp, this);
        this._observable.geoObjects.events
            .add('mouseup', this._onMouseUp, this);
    },
    _detachHandlers: function () {
        this._observable.geoObjects.events
            .remove('mouseup', this._onMouseUp, this);
        this._observable.events
            .remove('mouseup', this._onMouseUp, this)
            .remove('mousedown', this._onMouseDown, this);
    },
    _attachMovementHandlers: function () {
        this._observable.events
            .add('mousemove', this._onMouseMove, this);
    },
    _detachMovementHandlers: function () {
        this._observable.events
            .remove('mousemove', this._onMouseMove, this);
    },
    _attachClickHandlers: function () {
        this._observable.events
            .add('click', this._onClick, this);
    },
    _detachClickHandlers: function () {
        this._observable.events
            .remove('click', this._onClick, this);
    },
    _onMouseDown: function (e) {
        this._attachMovementHandlers();
        this.events.fire('selectcenter', e);
    },
    _onMouseUp: function (e) {
        this._detachMovementHandlers();
        this.events.fire('selectradius', e);
        this._detachHandlers();
        this._attachMovementHandlers();
    },
    _onMouseMove: function (e) {
        this.events.fire('searchvalue', e);
    },
    _onClick: function (e) {
        this._detachClickHandlers();
        this.events.fire('selectangle', e);
        this._attachHandlers();
    }
};

CircleSector.MapView = function (map) {
    this._map = map;

    this._center = null;
    this._radius = null;
    this._sector = null;

    this.events = new ymaps.event.Manager();
};

CircleSector.MapView.prototype = {
    constructor: CircleSector.MapView,
    setCenter: function (position) {
        this._map.geoObjects.add(
            this._center = new ymaps.Placemark(position)
        );

        return this;
    },
    unsetCenter: function () {
        if(this._center) {
            this._map.geoObjects.remove(this._center);
            this._center = null;
        }

        return this;
    },
    setRadius: function (position) {
        var center = this._center.geometry.getCoordinates(),
            distance = ymaps.coordSystem.geo
                .getDistance(center, position);

        this._updateRadius(position);

        this._map.hint.show(position, {
            content: ymaps.formatter.distance(distance)
        });

        return this;
    },
    clearRadius: function () {
        if(this._radius) {
            this._map.geoObjects.remove(this._radius);
            this._radius = null;
        }

        return this;
    },
    _updateRadius: function (position) {
        var center = this._center.geometry.getCoordinates();

        if(this._radius) {
            this._radius.geometry.setCoordinates([center, position]);
        }
        else {
            this._map.geoObjects.add(
                this._radius = new ymaps.Polyline([center, position], {}, {
                    strokeStyle: 'dash'
                })
            );
        }
    },
    setAngle: function (position) {
        var center = this._center.geometry.getCoordinates(),
            pointA = this._radius.geometry.get(1),
            sectorAngle = Math.PI / 4,
            // Решаем обратную задачу между двумя точками.
            geodesicRadius = ymaps.coordSystem.geo.solveInverseProblem(center, pointA),
            geodesicPosition = ymaps.coordSystem.geo.solveInverseProblem(center, position),
            // Находим угол в радианах.
            azimuthRadius = Math.atan2.apply(null, geodesicRadius.startDirection),
            azimuthPosition = Math.atan2.apply(null, geodesicPosition.startDirection),
            // Находим направления для сторон треугольника.
            directionPosition = geodesicPosition.startDirection,
            // Находим длину гипотенузы в метрах.
            // hypotenuseLength = geodesic.distance / Math.cos(sectorAngle / 2),
            distance = geodesicRadius.distance,
            // Находим координаты точек треугольника.
            pointB = ymaps.coordSystem.geo.solveDirectProblem(center, directionPosition, distance).endPoint,
            // Создаем объект, не забываем указать ему опцию geodesic: true.
            coordinates = [center, pointA],
            i = Math.min(azimuthRadius, azimuthPosition),
            j = Math.max(azimuthRadius, azimuthPosition);

        while(i < j) {
            i += 0.01;

            var dir = [Math.sin(i), Math.cos(i)],
                point = ymaps.coordSystem.geo.solveDirectProblem(center, dir, distance).endPoint;

            coordinates.push(point);
        }
        coordinates.push(pointB);
        this._map.geoObjects.add(
            this._sector = new ymaps.Polygon([coordinates], {}, {
                simplification: false
            })
        );

        return this;
    },
    unsetAngle: function () {
        if(this._sector) {
            this._map.geoObjects.remove(this._sector);
            this._sector = null;
        }

        return this;
    }
};

    </script>
    <style type="text/css">
        #YMapsID {
            width: 900px;
            height: 400px;
        }
    </style>
</head>
<body>
    <div class="hero-unit">
        <div class="container">
            <p>Построение сегмента круга</p>
            <div id="YMapsID"></div>
        </div>
    </div>
</body>
</html>
